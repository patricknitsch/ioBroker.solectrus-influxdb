{
	"BATTERY_DISCHARGING_POWER": "BATTERIA_SCARICA_POTENZA",
	"BATTERY_SOC": "BATTERIA_SOC",
	"Boolean": "Booleano",
	"Bucket": "Secchio",
	"Buffered points": "Punti bufferizzati",
	"CAR_BATTERY_SOC": "CAR_BATTERY_SOC",
	"CASE_TEMP": "CASO_TEMP",
	"CUSTOM_POWER_01": "CUSTOM_POWER_01",
	"CUSTOM_POWER_02": "CUSTOM_POWER_02",
	"CUSTOM_POWER_03": "CUSTOM_POWER_03",
	"CUSTOM_POWER_04": "CUSTOM_POWER_04",
	"CUSTOM_POWER_05": "CUSTOM_POWER_05",
	"CUSTOM_POWER_06": "CUSTOM_POWER_06",
	"CUSTOM_POWER_07": "CUSTOM_POWER_07",
	"CUSTOM_POWER_08": "CUSTOM_POWER_08",
	"CUSTOM_POWER_09": "CUSTOM_POWER_09",
	"CUSTOM_POWER_10": "CUSTOM_POWER_10",
	"CUSTOM_POWER_11": "CUSTOM_POWER_11",
	"CUSTOM_POWER_12": "CUSTOM_POWER_12",
	"CUSTOM_POWER_13": "CUSTOM_POWER_13",
	"CUSTOM_POWER_14": "CUSTOM_POWER_14",
	"CUSTOM_POWER_15": "CUSTOM_POWER_15",
	"CUSTOM_POWER_16": "CUSTOM_POWER_16",
	"CUSTOM_POWER_17": "CUSTOM_POWER_17",
	"CUSTOM_POWER_18": "CUSTOM_POWER_18",
	"CUSTOM_POWER_19": "CUSTOM_POWER_19",
	"CUSTOM_POWER_20": "CUSTOM_POWER_20",
	"Clear Buffer manually": "Cancella buffer manualmente",
	"Datatype": "Tipo di dati",
	"Device or service connected": "Dispositivo o servizio connesso",
	"Float": "Galleggiante",
	"GRID_EXPORT_LIMIT": "GRID_EXPORT_LIMIT",
	"GRID_EXPORT_POWER": "GRID_EXPORT_POWER",
	"GRID_IMPORT_POWER": "GRID_IMPORT_POWER",
	"HEATPUMP_HEATING_POWER": "POMPA DI CALORE_RISCALDAMENTO_POTENZA",
	"HEATPUMP_POWER": "POMPA DI CALORE_POTENZA",
	"HEATPUMP_STATUS": "POMPA DI CALORE_STATO",
	"HEATPUMP_TANK_TEMP": "POMPA DI CALORE_TANK_TEMP",
	"HOUSE_POWER": "CASA_POTENZA",
	"INVERTER_POWER": "INVERTER_POTENZA",
	"INVERTER_POWER_1": "INVERTER_POWER_1",
	"INVERTER_POWER_2": "INVERTER_POWER_2",
	"INVERTER_POWER_3": "INVERTER_POWER_3",
	"INVERTER_POWER_4": "INVERTER_POWER_4",
	"INVERTER_POWER_5": "INVERTER_POWER_5",
	"INVERTER_POWER_FORECAST": "INVERTER_POWER_PRECAST",
	"INVERTER_POWER_FORECAST_CLEARSKY": "INVERTER_POWER_FORECAST_CLEARSKY",
	"Influx Field": "Campo di afflusso",
	"Influx Measurement": "Misurazione dell'afflusso",
	"InfluxDB": "DB di afflusso",
	"InfluxDB URL": "URL del database di afflusso",
	"Integer": "Intero",
	"Last Error": "Ultimo errore",
	"OUTDOOR_TEMP": "ESTERNA_TEMP",
	"OUTDOOR_TEMP_FORECAST": "OUTDOOR_TEMP_PRECAST",
	"Oldest buffered timestamp": "Timestamp bufferizzato più vecchio",
	"Organization": "Organizzazione",
	"Polling Interval (s)": "Intervallo di polling (s)",
	"SOLECTRUS Sensors": "Sensori SOLECTRUS",
	"Sensors": "Sensori",
	"SYSTEM_STATUS": "STATO_SISTEMA",
	"SYSTEM_STATUS_OK": "STATO_SISTEMA_OK",
	"Sensor Name": "Nome del sensore",
	"Sensors Settings": "Impostazioni del sensore",
	"Standard": "Predefinito",
	"String": "Corda",
	"Token": "Gettone",
	"WALLBOX_CAR_CONNECTED": "WALLBOX_AUTO_CONNESSA",
	"WALLBOX_POWER": "WALLBOX_POWER",
	"ioBroker Source State": "Stato di origine di ioBroker",
	"Add": "Add",
	"Duplicate": "Duplicate",
	"Delete": "Delete",
	"Up": "Up",
	"Down": "Down",
	"Enabled": "Enabled",
	"Unnamed": "(unnamed)",
	"No sensors configured.": "No sensors configured.",
	"Select from existing states": "Select from existing states",
	"Selection dialog not available": "Selection dialog not available",
	"Select": "Select",
	"e.g. some.adapter.0.channel.state": "e.g. some.adapter.0.channel.state",
	"Select a sensor on the left or add a new one.": "Select a sensor on the left or add a new one.",
	"Master/detail editor for sensors. Shows enabled status live in the list.": "Master/detail editor for sensors. Shows enabled status live in the list.",
	"SOLECTRUS Quick Start (InfluxDB)": "Guida rapida SOLECTRUS\n1. Crea in InfluxDB 2.x un token API con permesso di scrittura per il tuo bucket.\n2. Inserisci URL, organizzazione, bucket e token a sinistra e salva.\n3. Apri la scheda “Sensori” e mappa i tuoi stati ioBroker.\n4. Abilita l’adattatore e controlla info.connection e gli stati del buffer.",
	"Open documentation": "Apri la documentazione",
	"Enable Data-SOLECTRUS (formula engine)": "Enable Data-SOLECTRUS (formula engine)",
	"Data Values": "Data Values",
	"Data Runtime": "Data Runtime",
	"dsValuesHint": "Configure computed values via the Master/Detail editor. Each value can mirror a source state or compute a formula from multiple inputs.",
	"dsPollIntervalLabel": "Poll interval (seconds)",
	"dsSnapshotInputsLabel": "Read inputs on tick (snapshot)",
	"dsSnapshotDelayLabel": "Snapshot delay (ms)",
	"Item": "Item",
	"No items configured.": "No items configured.",
	"Select an item on the left or add a new one.": "Select an item on the left or add a new one.",
	"Values": "Values",
	"Configure values via the Master/Detail editor.": "Configure values via the Master/Detail editor.",
	"Runtime": "Global settings",
	"Poll interval (seconds)": "Poll interval (seconds)",
	"Read inputs on tick (snapshot)": "Read inputs on tick (snapshot)",
	"Snapshot delay (ms)": "Snapshot delay (ms)",
	"Configured values": "Configured values",
	"Name": "Name",
	"Target ID": "Target ID",
	"Mode": "Mode",
	"Formula": "Formula",
	"Source": "Source",
	"State Machine": "State Machine",
	"Inputs": "Inputs",
	"Add input": "Add input",
	"Key": "Key",
	"Number": "Number",
	"Mixed": "Mixed",
	"Role": "Role",
	"Unit": "Unit",
	"Folder/Group": "Folder/Group",
	"Clamp result": "Clamp result",
	"Clamp negative to 0": "Clamp negative result to 0",
	"Clamp negative to 0 (hint source)": "Output only (does not change the source state).",
	"Clamp negative to 0 (hint formula)": "Output only. For single inputs use input neg→0.",
	"Clamp negative to 0 (tooltip)": "Clamps only the item result (output). If you want to clamp just one source/input, enable neg→0 on that input.",
	"Min": "Min",
	"Max": "Max",
	"Clamp input negative to 0": "Clamp input negative to 0",
	"Formula expression": "Formula expression",
	"Builder…": "Builder…",
	"Formula Builder": "Formula Builder",
	"Insert building blocks on the left. The editor uses current (unsaved) inputs.": "Insert building blocks on the left. The editor uses current (unsaved) inputs.",
	"Variables (Inputs)": "Variables (Inputs)",
	"No inputs configured yet.": "No inputs configured yet.",
	"Operators": "Operators",
	"Functions": "Functions",
	"State functions": "State functions",
	"Live values": "Live values",
	"Refresh": "Refresh",
	"Loading…": "Loading…",
	"Result": "Result",
	"Refresh preview": "Refresh preview",
	"Preview not available": "Preview not available",
	"Preview timeout": "Preview timeout",
	"Adapter not running": "Adapter not running",
	"Preview not supported for state functions": "Preview not supported for state functions",
	"Unterminated string": "Unterminated string",
	"Invalid number": "Invalid number",
	"Unexpected character": "Unexpected character",
	"Expected": "Expected",
	"Unexpected end": "Unexpected end",
	"Unknown function": "Unknown function",
	"Unsupported operator": "Unsupported operator",
	"Unexpected token": "Unexpected token",
	"n/a": "n/a",
	"negativeValuesHint": "Nota: SOLECTRUS non accetta valori negativi. Se un sensore fornisce valori negativi, verrà registrato un avviso una sola volta dopo l'avvio dell'adattatore. Controlla i tuoi stati sorgente oppure usa il motore formule Data-SOLECTRUS con l'opzione «Limita negativi a 0».",
	"Pick a state id and insert s(\"id\")": "Pick a state id and insert s(\"id\")",
	"Pick a state id and insert v(\"id\")": "Pick a state id and insert v(\"id\")",
	"Pick a state id and insert jp(\"id\", \"$.value\")": "Pick a state id and insert jp(\"id\", \"$.value\")",
	"Insert s()": "Insert s()",
	"Insert v()": "Insert v()",
	"Insert jp()": "Insert jp()",
	"Tip: You can still edit the formula as plain text anytime.": "Tip: You can still edit the formula as plain text anytime.",
	"Cancel": "Cancel",
	"Apply": "Apply",
	"Close": "Close",
	"min": "min",
	"max": "max",
	"clamp": "clamp",
	"IF": "IF",
	"JSONPath (optional)": "JSONPath (optional)",
	"e.g. $.apower": "e.g. $.apower",
	"e.g. pv1 + pv2 + pv3": "e.g. pv1 + pv2 + pv3",
	"Ungrouped": "Ungrouped",
	"active item": "active item",
	"active items": "active items",
	"inactive item": "inactive item",
	"inactive items": "inactive items",
	"Examples": "Examples",
	"Common formula patterns": "Common formula patterns",
	"op.+": "Addition: Adds two values. Example: a + b",
	"op.-": "Subtraction: Subtracts one value from another. Example: a - b",
	"op.*": "Multiplication: Multiplies two values. Example: a * b",
	"op./": "Division: Divides one value by another. Example: a / b",
	"op.%": "Modulo: Remainder of division. Example: 10 % 3 = 1",
	"op.()": "Parentheses: Controls calculation order. Example: (a + b) * c",
	"op.&&": "Logical AND: Both conditions must be true. Example: a > 0 && b > 0",
	"op.||": "Logical OR: At least one condition must be true. Example: a > 10 || b > 10",
	"op.!": "Logical NOT: Inverts a boolean value. Example: !condition",
	"op.==": "Equal: Tests for equality. Example: a == 5",
	"op.!=": "Not equal: Tests for inequality. Example: a != 0",
	"op.>=": "Greater or equal: Compares two values. Example: a >= 10",
	"op.<=": "Less or equal: Compares two values. Example: a <= 100",
	"op.>": "Greater than: Compares two values. Example: a > 0",
	"op.<": "Less than: Compares two values. Example: a < 100",
	"op.?:": "Ternary operator: If-Then-Else shorthand. Example: condition ? valueIfTrue : valueIfFalse",
	"fn.min": "Returns the smaller of two values. Example: min(5, 10) = 5",
	"fn.max": "Returns the larger of two values. Example: max(5, 10) = 10",
	"fn.clamp": "Clamps a value between min and max. Example: clamp(value, 0, 100)",
	"fn.IF": "If-Then-Else function. Example: IF(battery > 80, 1, 0)",
	"ex.sum": "PV Sum",
	"ex.sum.formula": "pv1 + pv2 + pv3",
	"ex.surplus": "PV Surplus",
	"ex.surplus.formula": "pv - houseConsumption",
	"ex.percent": "Calculate percentage",
	"ex.percent.formula": "(value / total) * 100",
	"ex.positive": "Only positive values",
	"ex.positive.formula": "max(0, value)",
	"ex.condition": "Condition (If-Then)",
	"ex.condition.formula": "IF(battery > 80, surplus, 0)",
	"ex.clamp01": "Clamp value to 0-1",
	"ex.clamp01.formula": "clamp(value / 100, 0, 1)",
	"Rules": "Rules",
	"Add rule": "Add rule",
	"Rule": "Rule",
	"Condition": "Condition",
	"Output Value": "Output Value",
	"Rules are evaluated top-to-bottom; first matching rule wins.": "Rules are evaluated top-to-bottom; first matching rule wins.",
	"Use inputs and operators: <, >, ==, &&, ||": "Use inputs and operators: <, >, ==, &&, ||",
	"Formula syntax: soc < 10, battery > 80 && surplus > 0, true (for default/fallback)": "Formula syntax: soc < 10, battery > 80 && surplus > 0, true (for default/fallback)",
	"e.g. soc < 10 or true for default": "e.g. soc < 10 or true for default",
	"e.g. Battery-Empty": "e.g. Battery-Empty",
	"Forecast": "Previsione",
	"forecastHint": "Configura le fonti di previsione da pvforecast o adattatori simili. L'adattatore si iscrive a uno stato JSON, analizza l'array e scrive ogni voce in InfluxDB con il timestamp dai dati JSON. I punti esistenti vengono aggiornati automaticamente quando i dati di previsione cambiano.",
	"Forecast Sources": "Fonti di previsione",
	"Timestamp Field": "Campo timestamp",
	"Value Field": "Campo valore",
	"e.g. INVERTER_POWER_FORECAST": "es. INVERTER_POWER_FORECAST",
	"e.g. pvforecast.0.summary.JSONData": "es. pvforecast.0.summary.JSONData",
	"e.g. inverter_forecast": "es. inverter_forecast",
	"e.g. power": "es. power",
	"No forecasts configured.": "Nessuna previsione configurata.",
	"Select a forecast on the left or add a new one.": "Seleziona una previsione a sinistra o creane una nuova.",
	"forecastEntryHint": "L'adattatore si iscrive allo stato JSON di origine e scrive ogni voce dell'array in InfluxDB utilizzando il timestamp dai dati JSON. Più voci possono puntare alla stessa sorgente ma estrarre diversi campi valore (es. y, clearsky, temp).",
	"Enable Forecast Sources": "Attiva fonti di previsione",
	"JSON Array": "Array JSON",
	"JSON Preset": "Modello JSON",
	"Forecast (y)": "Previsione (y)",
	"Clearsky": "Clearsky",
	"Temperature (temp)": "Temperatura (temp)",
	"Weather Code": "Codice meteo",
	"Custom": "Personalizzato",
	"JSON Timestamp Field": "Campo timestamp JSON",
	"JSON Value Field": "Campo valore JSON",
	"Influx Type": "Tipo Influx",
	"jsonSensorDetailHint": "Lo stato sorgente deve contenere un array JSON (es. da pvforecast). Ogni voce dell'array viene analizzata e scritta direttamente in InfluxDB con il timestamp originale. Non vengono creati stati intermedi – l'elaborazione avviene interamente in memoria. Per i modelli predefiniti, la mappatura dei campi viene impostata automaticamente. Per i tipi personalizzati, specifica la chiave JSON per timestamp e valore.",
	"jsonSensorHint": "I dati di previsione/meteo possono essere configurati come sensori JSON nella scheda Sensori (tipo di dati: Array JSON)."
}
