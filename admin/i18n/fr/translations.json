{
	"BATTERY_CHARGING_POWER": "BATTERY_CHARGING_POWER",
	"BATTERY_DISCHARGING_POWER": "BATTERY_DISCHARGING_POWER",
	"BATTERY_SOC": "BATTERIE_SOC",
	"Boolean": "Booléen",
	"Bucket": "Seau",
	"Buffered points": "Points tampons",
	"CAR_BATTERY_SOC": "CAR_BATTERY_SOC",
	"CASE_TEMP": "CASE_TEMP",
	"CUSTOM_POWER_01": "CUSTOM_POWER_01",
	"CUSTOM_POWER_02": "CUSTOM_POWER_02",
	"CUSTOM_POWER_03": "CUSTOM_POWER_03",
	"CUSTOM_POWER_04": "CUSTOM_POWER_04",
	"CUSTOM_POWER_05": "CUSTOM_POWER_05",
	"CUSTOM_POWER_06": "CUSTOM_POWER_06",
	"CUSTOM_POWER_07": "CUSTOM_POWER_07",
	"CUSTOM_POWER_08": "CUSTOM_POWER_08",
	"CUSTOM_POWER_09": "CUSTOM_POWER_09",
	"CUSTOM_POWER_10": "CUSTOM_POWER_10",
	"CUSTOM_POWER_11": "CUSTOM_POWER_11",
	"CUSTOM_POWER_12": "CUSTOM_POWER_12",
	"CUSTOM_POWER_13": "CUSTOM_POWER_13",
	"CUSTOM_POWER_14": "CUSTOM_POWER_14",
	"CUSTOM_POWER_15": "CUSTOM_POWER_15",
	"CUSTOM_POWER_16": "CUSTOM_POWER_16",
	"CUSTOM_POWER_17": "CUSTOM_POWER_17",
	"CUSTOM_POWER_18": "CUSTOM_POWER_18",
	"CUSTOM_POWER_19": "CUSTOM_POWER_19",
	"CUSTOM_POWER_20": "CUSTOM_POWER_20",
	"Clear Buffer manually": "Effacer le tampon manuellement",
	"Datatype": "Type de données",
	"Device or service connected": "Appareil ou service connecté",
	"Float": "Flotter",
	"GRID_EXPORT_LIMIT": "GRID_EXPORT_LIMIT",
	"GRID_EXPORT_POWER": "GRID_EXPORT_POWER",
	"GRID_IMPORT_POWER": "GRID_IMPORT_POWER",
	"HEATPUMP_HEATING_POWER": "HEATPUMP_HEATING_POWER",
	"HEATPUMP_POWER": "HEATPUMP_POWER",
	"HEATPUMP_STATUS": "HEATPUMP_STATUS",
	"HEATPUMP_TANK_TEMP": "HEATPUMP_TANK_TEMP",
	"HOUSE_POWER": "MAISON_POWER",
	"INVERTER_POWER": "INVERTER_POWER",
	"INVERTER_POWER_1": "INVERTER_POWER_1",
	"INVERTER_POWER_2": "INVERTER_POWER_2",
	"INVERTER_POWER_3": "INVERTER_POWER_3",
	"INVERTER_POWER_4": "INVERTER_POWER_4",
	"INVERTER_POWER_5": "INVERTER_POWER_5",
	"INVERTER_POWER_FORECAST": "INVERTER_POWER_FORECAST",
	"INVERTER_POWER_FORECAST_CLEARSKY": "INVERTER_POWER_FORECAST_CLEARSKY",
	"Influx Field": "Champ d'afflux",
	"Influx Measurement": "Mesure d'afflux",
	"InfluxDB": "InfluxDB",
	"InfluxDB URL": "URL d'InfluxDB",
	"Integer": "Entier",
	"Last Error": "Dernière erreur",
	"OUTDOOR_TEMP": "OUTDOOR_TEMP",
	"OUTDOOR_TEMP_FORECAST": "OUTDOOR_TEMP_FORECAST",
	"Oldest buffered timestamp": "Horodatage mis en mémoire tampon le plus ancien",
	"Organization": "Organisation",
	"Polling Interval (s)": "Intervalle(s) d'interrogation",
	"SOLECTRUS Sensors": "Capteurs SOLECTRUS",
	"Sensors": "Capteurs",
	"SYSTEM_STATUS": "STATUT_SYSTÈME",
	"SYSTEM_STATUS_OK": "SYSTEM_STATUS_OK",
	"Sensor Name": "Nom du capteur",
	"Sensors Settings": "Paramètres du capteur",
	"Standard": "Défaut",
	"String": "Chaîne",
	"Token": "Jeton",
	"WALLBOX_CAR_CONNECTED": "WALLBOX_CAR_CONNECTED",
	"WALLBOX_POWER": "WALLBOX_POWER",
	"ioBroker Source State": "État source d'ioBroker",
	"Add": "Add",
	"Duplicate": "Duplicate",
	"Delete": "Delete",
	"Up": "Up",
	"Down": "Down",
	"Enabled": "Enabled",
	"Unnamed": "(unnamed)",
	"No sensors configured.": "No sensors configured.",
	"Select from existing states": "Select from existing states",
	"Selection dialog not available": "Selection dialog not available",
	"Select": "Select",
	"e.g. some.adapter.0.channel.state": "e.g. some.adapter.0.channel.state",
	"Select a sensor on the left or add a new one.": "Select a sensor on the left or add a new one.",
	"Master/detail editor for sensors. Shows enabled status live in the list.": "Master/detail editor for sensors. Shows enabled status live in the list.",
	"SOLECTRUS Quick Start (InfluxDB)": "Guide rapide SOLECTRUS\n1. Créez dans InfluxDB 2.x un jeton API avec droit d’écriture sur votre bucket.\n2. Saisissez l’URL, l’organisation, le bucket et le jeton à gauche et enregistrez.\n3. Ouvrez l’onglet « Capteurs » et mappez vos états ioBroker.\n4. Activez l’adaptateur et vérifiez info.connection et les états du buffer.",
	"Open documentation": "Ouvrir la documentation",
	"Enable Data-SOLECTRUS (formula engine)": "Enable Data-SOLECTRUS (formula engine)",
	"Data Values": "Data Values",
	"Data Runtime": "Data Runtime",
	"dsValuesHint": "Configure computed values via the Master/Detail editor. Each value can mirror a source state or compute a formula from multiple inputs.",
	"dsPollIntervalLabel": "Poll interval (seconds)",
	"dsSnapshotInputsLabel": "Read inputs on tick (snapshot)",
	"dsSnapshotDelayLabel": "Snapshot delay (ms)",
	"Item": "Item",
	"No items configured.": "No items configured.",
	"Select an item on the left or add a new one.": "Select an item on the left or add a new one.",
	"Values": "Values",
	"Configure values via the Master/Detail editor.": "Configure values via the Master/Detail editor.",
	"Runtime": "Global settings",
	"Poll interval (seconds)": "Poll interval (seconds)",
	"Read inputs on tick (snapshot)": "Read inputs on tick (snapshot)",
	"Snapshot delay (ms)": "Snapshot delay (ms)",
	"Configured values": "Configured values",
	"Name": "Name",
	"Target ID": "Target ID",
	"Mode": "Mode",
	"Formula": "Formula",
	"Source": "Source",
	"State Machine": "State Machine",
	"Inputs": "Inputs",
	"Add input": "Add input",
	"Key": "Key",
	"Number": "Number",
	"Mixed": "Mixed",
	"Role": "Role",
	"Unit": "Unit",
	"Folder/Group": "Folder/Group",
	"Clamp result": "Clamp result",
	"Clamp negative to 0": "Clamp negative result to 0",
	"Clamp negative to 0 (hint source)": "Output only (does not change the source state).",
	"Clamp negative to 0 (hint formula)": "Output only. For single inputs use input neg→0.",
	"Clamp negative to 0 (tooltip)": "Clamps only the item result (output). If you want to clamp just one source/input, enable neg→0 on that input.",
	"Min": "Min",
	"Max": "Max",
	"Clamp input negative to 0": "Clamp input negative to 0",
	"Formula expression": "Formula expression",
	"Builder…": "Builder…",
	"Formula Builder": "Formula Builder",
	"Insert building blocks on the left. The editor uses current (unsaved) inputs.": "Insert building blocks on the left. The editor uses current (unsaved) inputs.",
	"Variables (Inputs)": "Variables (Inputs)",
	"No inputs configured yet.": "No inputs configured yet.",
	"Operators": "Operators",
	"Functions": "Functions",
	"State functions": "State functions",
	"Live values": "Live values",
	"Refresh": "Refresh",
	"Loading…": "Loading…",
	"Result": "Result",
	"Refresh preview": "Refresh preview",
	"Preview not available": "Preview not available",
	"Preview timeout": "Preview timeout",
	"Adapter not running": "Adapter not running",
	"Preview not supported for state functions": "Preview not supported for state functions",
	"Unterminated string": "Unterminated string",
	"Invalid number": "Invalid number",
	"Unexpected character": "Unexpected character",
	"Expected": "Expected",
	"Unexpected end": "Unexpected end",
	"Unknown function": "Unknown function",
	"Unsupported operator": "Unsupported operator",
	"Unexpected token": "Unexpected token",
	"n/a": "n/a",
	"negativeValuesHint": "Remarque : SOLECTRUS n'accepte pas les valeurs négatives. Si un capteur fournit des valeurs négatives, un avertissement sera enregistré une seule fois après le démarrage de l'adaptateur. Vérifiez vos états source ou utilisez le moteur de formules Data-SOLECTRUS avec l'option « Limiter les négatifs à 0 ».",
	"Pick a state id and insert s(\"id\")": "Pick a state id and insert s(\"id\")",
	"Pick a state id and insert v(\"id\")": "Pick a state id and insert v(\"id\")",
	"Pick a state id and insert jp(\"id\", \"$.value\")": "Pick a state id and insert jp(\"id\", \"$.value\")",
	"Insert s()": "Insert s()",
	"Insert v()": "Insert v()",
	"Insert jp()": "Insert jp()",
	"Tip: You can still edit the formula as plain text anytime.": "Tip: You can still edit the formula as plain text anytime.",
	"Cancel": "Cancel",
	"Apply": "Apply",
	"Close": "Close",
	"min": "min",
	"max": "max",
	"clamp": "clamp",
	"IF": "IF",
	"JSONPath (optional)": "JSONPath (optional)",
	"e.g. $.apower": "e.g. $.apower",
	"e.g. pv1 + pv2 + pv3": "e.g. pv1 + pv2 + pv3",
	"Ungrouped": "Ungrouped",
	"active item": "active item",
	"active items": "active items",
	"inactive item": "inactive item",
	"inactive items": "inactive items",
	"Examples": "Examples",
	"Common formula patterns": "Common formula patterns",
	"op.+": "Addition: Adds two values. Example: a + b",
	"op.-": "Subtraction: Subtracts one value from another. Example: a - b",
	"op.*": "Multiplication: Multiplies two values. Example: a * b",
	"op./": "Division: Divides one value by another. Example: a / b",
	"op.%": "Modulo: Remainder of division. Example: 10 % 3 = 1",
	"op.()": "Parentheses: Controls calculation order. Example: (a + b) * c",
	"op.&&": "Logical AND: Both conditions must be true. Example: a > 0 && b > 0",
	"op.||": "Logical OR: At least one condition must be true. Example: a > 10 || b > 10",
	"op.!": "Logical NOT: Inverts a boolean value. Example: !condition",
	"op.==": "Equal: Tests for equality. Example: a == 5",
	"op.!=": "Not equal: Tests for inequality. Example: a != 0",
	"op.>=": "Greater or equal: Compares two values. Example: a >= 10",
	"op.<=": "Less or equal: Compares two values. Example: a <= 100",
	"op.>": "Greater than: Compares two values. Example: a > 0",
	"op.<": "Less than: Compares two values. Example: a < 100",
	"op.?:": "Ternary operator: If-Then-Else shorthand. Example: condition ? valueIfTrue : valueIfFalse",
	"fn.min": "Returns the smaller of two values. Example: min(5, 10) = 5",
	"fn.max": "Returns the larger of two values. Example: max(5, 10) = 10",
	"fn.clamp": "Clamps a value between min and max. Example: clamp(value, 0, 100)",
	"fn.IF": "If-Then-Else function. Example: IF(battery > 80, 1, 0)",
	"ex.sum": "PV Sum",
	"ex.sum.formula": "pv1 + pv2 + pv3",
	"ex.surplus": "PV Surplus",
	"ex.surplus.formula": "pv - houseConsumption",
	"ex.percent": "Calculate percentage",
	"ex.percent.formula": "(value / total) * 100",
	"ex.positive": "Only positive values",
	"ex.positive.formula": "max(0, value)",
	"ex.condition": "Condition (If-Then)",
	"ex.condition.formula": "IF(battery > 80, surplus, 0)",
	"ex.clamp01": "Clamp value to 0-1",
	"ex.clamp01.formula": "clamp(value / 100, 0, 1)",
	"Rules": "Rules",
	"Add rule": "Add rule",
	"Rule": "Rule",
	"Condition": "Condition",
	"Output Value": "Output Value",
	"Rules are evaluated top-to-bottom; first matching rule wins.": "Rules are evaluated top-to-bottom; first matching rule wins.",
	"Use inputs and operators: <, >, ==, &&, ||": "Use inputs and operators: <, >, ==, &&, ||",
	"Formula syntax: soc < 10, battery > 80 && surplus > 0, true (for default/fallback)": "Formula syntax: soc < 10, battery > 80 && surplus > 0, true (for default/fallback)",
	"e.g. soc < 10 or true for default": "e.g. soc < 10 or true for default",
	"e.g. Battery-Empty": "e.g. Battery-Empty",
	"Forecast": "Prévision",
	"forecastHint": "Configurez les sources de prévision de pvforecast ou d'adaptateurs similaires. L'adaptateur s'abonne à un état JSON, analyse le tableau et écrit chaque entrée dans InfluxDB avec l'horodatage des données JSON. Les points existants sont automatiquement mis à jour lorsque les données de prévision changent.",
	"Forecast Sources": "Sources de prévision",
	"Timestamp Field": "Champ d'horodatage",
	"Value Field": "Champ de valeur",
	"e.g. INVERTER_POWER_FORECAST": "p.ex. INVERTER_POWER_FORECAST",
	"e.g. pvforecast.0.summary.JSONData": "p.ex. pvforecast.0.summary.JSONData",
	"e.g. inverter_forecast": "p.ex. inverter_forecast",
	"e.g. power": "p.ex. power",
	"No forecasts configured.": "Aucune prévision configurée.",
	"Select a forecast on the left or add a new one.": "Sélectionnez une prévision à gauche ou créez-en une nouvelle.",
	"forecastEntryHint": "L'adaptateur s'abonne à l'état JSON source et écrit chaque entrée du tableau dans InfluxDB en utilisant l'horodatage des données JSON. Plusieurs entrées peuvent pointer vers la même source mais extraire différents champs de valeur (p.ex. y, clearsky, temp).",
	"Enable Forecast Sources": "Activer les sources de prévision",
	"JSON Array": "Tableau JSON",
	"JSON Preset": "Modèle JSON",
	"Forecast (y)": "Prévision (y)",
	"Clearsky": "Clearsky",
	"Temperature (temp)": "Température (temp)",
	"Weather Code": "Code météo",
	"Custom": "Personnalisé",
	"JSON Timestamp Field": "Champ d'horodatage JSON",
	"JSON Value Field": "Champ de valeur JSON",
	"Influx Type": "Type Influx",
	"jsonSensorDetailHint": "L'état source doit contenir un tableau JSON (p.ex. de pvforecast). Chaque entrée du tableau est analysée et écrite directement dans InfluxDB avec l'horodatage original. Aucun état intermédiaire n'est créé – le traitement s'exécute entièrement en mémoire. Pour les modèles prédéfinis, le mappage des champs est configuré automatiquement. Pour les types personnalisés, spécifiez la clé JSON pour l'horodatage et la valeur.",
	"jsonSensorHint": "Les données de prévision/météo peuvent être configurées comme capteurs JSON dans l'onglet Capteurs (type de données : Tableau JSON)."
}
