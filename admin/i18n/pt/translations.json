{
	"BATTERY_CHARGING_POWER": "BATTERY_CHARGING_POWER",
	"BATTERY_DISCHARGING_POWER": "BATTERY_DISCHARGING_POWER",
	"BATTERY_SOC": "BATTERY_SOC",
	"Boolean": "Booleano",
	"Bucket": "Balde",
	"Buffered points": "Pontos protegidos",
	"CAR_BATTERY_SOC": "CAR_BATTERY_SOC",
	"CASE_TEMP": "CASE_TEMP",
	"CUSTOM_POWER_01": "CUSTOM_POWER_01",
	"CUSTOM_POWER_02": "CUSTOM_POWER_02",
	"CUSTOM_POWER_03": "CUSTOM_POWER_03",
	"CUSTOM_POWER_04": "CUSTOM_POWER_04",
	"CUSTOM_POWER_05": "CUSTOM_POWER_05",
	"CUSTOM_POWER_06": "CUSTOM_POWER_06",
	"CUSTOM_POWER_07": "CUSTOM_POWER_07",
	"CUSTOM_POWER_08": "CUSTOM_POWER_08",
	"CUSTOM_POWER_09": "CUSTOM_POWER_09",
	"CUSTOM_POWER_10": "CUSTOM_POWER_10",
	"CUSTOM_POWER_11": "CUSTOM_POWER_11",
	"CUSTOM_POWER_12": "CUSTOM_POWER_12",
	"CUSTOM_POWER_13": "CUSTOM_POWER_13",
	"CUSTOM_POWER_14": "CUSTOM_POWER_14",
	"CUSTOM_POWER_15": "CUSTOM_POWER_15",
	"CUSTOM_POWER_16": "CUSTOM_POWER_16",
	"CUSTOM_POWER_17": "CUSTOM_POWER_17",
	"CUSTOM_POWER_18": "CUSTOM_POWER_18",
	"CUSTOM_POWER_19": "CUSTOM_POWER_19",
	"CUSTOM_POWER_20": "CUSTOM_POWER_20",
	"Clear Buffer manually": "Limpar buffer manualmente",
	"Datatype": "Tipo de dados",
	"Device or service connected": "Dispositivo ou serviço conectado",
	"Float": "Flutuador",
	"GRID_EXPORT_LIMIT": "GRID_EXPORT_LIMIT",
	"GRID_EXPORT_POWER": "GRID_EXPORT_POWER",
	"GRID_IMPORT_POWER": "GRID_IMPORT_POWER",
	"HEATPUMP_HEATING_POWER": "HEATPUMP_HEATING_POWER",
	"HEATPUMP_POWER": "HEATPUMP_POWER",
	"HEATPUMP_STATUS": "HEATPUMP_STATUS",
	"HEATPUMP_TANK_TEMP": "HEATPUMP_TANK_TEMP",
	"HOUSE_POWER": "CASA_POWER",
	"INVERTER_POWER": "INVERTER_POWER",
	"INVERTER_POWER_1": "INVERTER_POWER_1",
	"INVERTER_POWER_2": "INVERSOR_POWER_2",
	"INVERTER_POWER_3": "INVERSOR_POWER_3",
	"INVERTER_POWER_4": "INVERSOR_POWER_4",
	"INVERTER_POWER_5": "INVERSOR_POWER_5",
	"INVERTER_POWER_FORECAST": "INVERTER_POWER_FORECAST",
	"INVERTER_POWER_FORECAST_CLEARSKY": "INVERTER_POWER_FORECAST_CLEARSKY",
	"Influx Field": "Campo de Influxo",
	"Influx Measurement": "Medição de Influxo",
	"InfluxDB": "InfluxoDB",
	"InfluxDB URL": "URL do InfluxDB",
	"Integer": "Inteiro",
	"Last Error": "Último erro",
	"OUTDOOR_TEMP": "EXTERIOR_TEMP",
	"OUTDOOR_TEMP_FORECAST": "EXTERIOR_TEMP_FORECAST",
	"Oldest buffered timestamp": "Carimbo de data/hora em buffer mais antigo",
	"Organization": "Organização",
	"Polling Interval (s)": "Intervalo(s) de pesquisa",
	"SOLECTRUS Sensors": "Sensores SOLECTRUS",
	"Sensors": "Sensores",
	"SYSTEM_STATUS": "SYSTEM_STATUS",
	"SYSTEM_STATUS_OK": "SYSTEM_STATUS_OK",
	"Sensor Name": "Nome do sensor",
	"Sensors Settings": "Configurações do sensor",
	"Standard": "Padrão",
	"String": "Corda",
	"Token": "Símbolo",
	"WALLBOX_CAR_CONNECTED": "WALLBOX_CAR_CONNECTED",
	"WALLBOX_POWER": "WALLBOX_POWER",
	"ioBroker Source State": "Estado de origem do ioBroker",
	"Add": "Add",
	"Duplicate": "Duplicate",
	"Delete": "Delete",
	"Up": "Up",
	"Down": "Down",
	"Enabled": "Enabled",
	"Unnamed": "(unnamed)",
	"No sensors configured.": "No sensors configured.",
	"Select from existing states": "Select from existing states",
	"Selection dialog not available": "Selection dialog not available",
	"Select": "Select",
	"e.g. some.adapter.0.channel.state": "e.g. some.adapter.0.channel.state",
	"Select a sensor on the left or add a new one.": "Select a sensor on the left or add a new one.",
	"Master/detail editor for sensors. Shows enabled status live in the list.": "Master/detail editor for sensors. Shows enabled status live in the list.",
	"SOLECTRUS Quick Start (InfluxDB)": "Guia rápido SOLECTRUS\n1. Crie no InfluxDB 2.x um token de API com permissão de escrita para o seu bucket.\n2. Insira URL, organização, bucket e token à esquerda e salve.\n3. Abra a aba “Sensores” e mapeie seus estados do ioBroker.\n4. Ative o adaptador e verifique info.connection e os estados do buffer.",
	"Open documentation": "Abrir documentação",
	"Enable Data-SOLECTRUS (formula engine)": "Enable Data-SOLECTRUS (formula engine)",
	"Data Values": "Data Values",
	"Data Runtime": "Data Runtime",
	"dsValuesHint": "Configure computed values via the Master/Detail editor. Each value can mirror a source state or compute a formula from multiple inputs.",
	"dsPollIntervalLabel": "Poll interval (seconds)",
	"dsSnapshotInputsLabel": "Read inputs on tick (snapshot)",
	"dsSnapshotDelayLabel": "Snapshot delay (ms)",
	"Item": "Item",
	"No items configured.": "No items configured.",
	"Select an item on the left or add a new one.": "Select an item on the left or add a new one.",
	"Values": "Values",
	"Configure values via the Master/Detail editor.": "Configure values via the Master/Detail editor.",
	"Runtime": "Global settings",
	"Poll interval (seconds)": "Poll interval (seconds)",
	"Read inputs on tick (snapshot)": "Read inputs on tick (snapshot)",
	"Snapshot delay (ms)": "Snapshot delay (ms)",
	"Configured values": "Configured values",
	"Name": "Name",
	"Target ID": "Target ID",
	"Mode": "Mode",
	"Formula": "Formula",
	"Source": "Source",
	"State Machine": "State Machine",
	"Inputs": "Inputs",
	"Add input": "Add input",
	"Key": "Key",
	"Number": "Number",
	"Mixed": "Mixed",
	"Role": "Role",
	"Unit": "Unit",
	"Folder/Group": "Folder/Group",
	"Clamp result": "Clamp result",
	"Clamp negative to 0": "Clamp negative result to 0",
	"Clamp negative to 0 (hint source)": "Output only (does not change the source state).",
	"Clamp negative to 0 (hint formula)": "Output only. For single inputs use input neg→0.",
	"Clamp negative to 0 (tooltip)": "Clamps only the item result (output). If you want to clamp just one source/input, enable neg→0 on that input.",
	"Min": "Min",
	"Max": "Max",
	"Clamp input negative to 0": "Clamp input negative to 0",
	"Formula expression": "Formula expression",
	"Builder…": "Builder…",
	"Formula Builder": "Formula Builder",
	"Insert building blocks on the left. The editor uses current (unsaved) inputs.": "Insert building blocks on the left. The editor uses current (unsaved) inputs.",
	"Variables (Inputs)": "Variables (Inputs)",
	"No inputs configured yet.": "No inputs configured yet.",
	"Operators": "Operators",
	"Functions": "Functions",
	"State functions": "State functions",
	"Live values": "Live values",
	"Refresh": "Refresh",
	"Loading…": "Loading…",
	"Result": "Result",
	"Refresh preview": "Refresh preview",
	"Preview not available": "Preview not available",
	"Preview timeout": "Preview timeout",
	"Adapter not running": "Adapter not running",
	"Preview not supported for state functions": "Preview not supported for state functions",
	"Unterminated string": "Unterminated string",
	"Invalid number": "Invalid number",
	"Unexpected character": "Unexpected character",
	"Expected": "Expected",
	"Unexpected end": "Unexpected end",
	"Unknown function": "Unknown function",
	"Unsupported operator": "Unsupported operator",
	"Unexpected token": "Unexpected token",
	"n/a": "n/a",
	"negativeValuesHint": "Nota: SOLECTRUS não aceita valores negativos. Se um sensor fornecer valores negativos, um aviso será registrado uma vez após o início do adaptador. Verifique seus estados de origem ou use o motor de fórmulas Data-SOLECTRUS com a opção «Limitar negativos a 0».",
	"Pick a state id and insert s(\"id\")": "Pick a state id and insert s(\"id\")",
	"Pick a state id and insert v(\"id\")": "Pick a state id and insert v(\"id\")",
	"Pick a state id and insert jp(\"id\", \"$.value\")": "Pick a state id and insert jp(\"id\", \"$.value\")",
	"Insert s()": "Insert s()",
	"Insert v()": "Insert v()",
	"Insert jp()": "Insert jp()",
	"Tip: You can still edit the formula as plain text anytime.": "Tip: You can still edit the formula as plain text anytime.",
	"Cancel": "Cancel",
	"Apply": "Apply",
	"Close": "Close",
	"min": "min",
	"max": "max",
	"clamp": "clamp",
	"IF": "IF",
	"JSONPath (optional)": "JSONPath (optional)",
	"e.g. $.apower": "e.g. $.apower",
	"e.g. pv1 + pv2 + pv3": "e.g. pv1 + pv2 + pv3",
	"Ungrouped": "Ungrouped",
	"active item": "active item",
	"active items": "active items",
	"inactive item": "inactive item",
	"inactive items": "inactive items",
	"Examples": "Examples",
	"Common formula patterns": "Common formula patterns",
	"op.+": "Addition: Adds two values. Example: a + b",
	"op.-": "Subtraction: Subtracts one value from another. Example: a - b",
	"op.*": "Multiplication: Multiplies two values. Example: a * b",
	"op./": "Division: Divides one value by another. Example: a / b",
	"op.%": "Modulo: Remainder of division. Example: 10 % 3 = 1",
	"op.()": "Parentheses: Controls calculation order. Example: (a + b) * c",
	"op.&&": "Logical AND: Both conditions must be true. Example: a > 0 && b > 0",
	"op.||": "Logical OR: At least one condition must be true. Example: a > 10 || b > 10",
	"op.!": "Logical NOT: Inverts a boolean value. Example: !condition",
	"op.==": "Equal: Tests for equality. Example: a == 5",
	"op.!=": "Not equal: Tests for inequality. Example: a != 0",
	"op.>=": "Greater or equal: Compares two values. Example: a >= 10",
	"op.<=": "Less or equal: Compares two values. Example: a <= 100",
	"op.>": "Greater than: Compares two values. Example: a > 0",
	"op.<": "Less than: Compares two values. Example: a < 100",
	"op.?:": "Ternary operator: If-Then-Else shorthand. Example: condition ? valueIfTrue : valueIfFalse",
	"fn.min": "Returns the smaller of two values. Example: min(5, 10) = 5",
	"fn.max": "Returns the larger of two values. Example: max(5, 10) = 10",
	"fn.clamp": "Clamps a value between min and max. Example: clamp(value, 0, 100)",
	"fn.IF": "If-Then-Else function. Example: IF(battery > 80, 1, 0)",
	"ex.sum": "PV Sum",
	"ex.sum.formula": "pv1 + pv2 + pv3",
	"ex.surplus": "PV Surplus",
	"ex.surplus.formula": "pv - houseConsumption",
	"ex.percent": "Calculate percentage",
	"ex.percent.formula": "(value / total) * 100",
	"ex.positive": "Only positive values",
	"ex.positive.formula": "max(0, value)",
	"ex.condition": "Condition (If-Then)",
	"ex.condition.formula": "IF(battery > 80, surplus, 0)",
	"ex.clamp01": "Clamp value to 0-1",
	"ex.clamp01.formula": "clamp(value / 100, 0, 1)",
	"Rules": "Rules",
	"Add rule": "Add rule",
	"Rule": "Rule",
	"Condition": "Condition",
	"Output Value": "Output Value",
	"Rules are evaluated top-to-bottom; first matching rule wins.": "Rules are evaluated top-to-bottom; first matching rule wins.",
	"Use inputs and operators: <, >, ==, &&, ||": "Use inputs and operators: <, >, ==, &&, ||",
	"Formula syntax: soc < 10, battery > 80 && surplus > 0, true (for default/fallback)": "Formula syntax: soc < 10, battery > 80 && surplus > 0, true (for default/fallback)",
	"e.g. soc < 10 or true for default": "e.g. soc < 10 or true for default",
	"e.g. Battery-Empty": "e.g. Battery-Empty",
	"Forecast": "Previsão",
	"forecastHint": "Configure fontes de previsão do pvforecast ou adaptadores semelhantes. O adaptador assina um estado JSON, analisa o array e escreve cada entrada no InfluxDB com o timestamp dos dados JSON. Pontos existentes são atualizados automaticamente quando os dados de previsão mudam.",
	"Forecast Sources": "Fontes de previsão",
	"Timestamp Field": "Campo de timestamp",
	"Value Field": "Campo de valor",
	"e.g. INVERTER_POWER_FORECAST": "ex. INVERTER_POWER_FORECAST",
	"e.g. pvforecast.0.summary.JSONData": "ex. pvforecast.0.summary.JSONData",
	"e.g. inverter_forecast": "ex. inverter_forecast",
	"e.g. power": "ex. power",
	"No forecasts configured.": "Nenhuma previsão configurada.",
	"Select a forecast on the left or add a new one.": "Selecione uma previsão à esquerda ou crie uma nova.",
	"forecastEntryHint": "O adaptador assina o estado JSON de origem e escreve cada entrada do array no InfluxDB usando o timestamp dos dados JSON. Várias entradas podem apontar para a mesma fonte mas extrair diferentes campos de valor (ex. y, clearsky, temp).",
	"Enable Forecast Sources": "Ativar fontes de previsão",
	"JSON Array": "Array JSON",
	"JSON Preset": "Modelo JSON",
	"Forecast (y)": "Previsão (y)",
	"Clearsky": "Clearsky",
	"Temperature (temp)": "Temperatura (temp)",
	"Weather Code": "Código meteorológico",
	"Custom": "Personalizado",
	"JSON Timestamp Field": "Campo de carimbo de data/hora JSON",
	"JSON Value Field": "Campo de valor JSON",
	"Influx Type": "Tipo Influx",
	"jsonSensorDetailHint": "O estado de origem deve conter um array JSON (ex. de pvforecast). Cada entrada do array é analisada e escrita diretamente no InfluxDB com o carimbo de data/hora original. Não são criados estados intermediários – o processamento ocorre inteiramente na memória. Para modelos predefinidos, o mapeamento de campos é configurado automaticamente. Para tipos personalizados, especifique a chave JSON para carimbo de data/hora e valor.",
	"jsonSensorHint": "Os dados de previsão/meteorologia podem ser configurados como sensores JSON na aba Sensores (tipo de dados: Array JSON)."
}
